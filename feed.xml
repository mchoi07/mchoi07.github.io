<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>https://mchoi07.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 07 Dec 2019 21:25:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>암호화복호화</title>
      <link>https://mchoi07.github.io/2019/12/07/%EC%95%94%ED%98%B8%ED%99%94%EB%B3%B5%ED%98%B8%ED%99%94/</link>
      <guid>https://mchoi07.github.io/2019/12/07/%EC%95%94%ED%98%B8%ED%99%94%EB%B3%B5%ED%98%B8%ED%99%94/</guid>
      <pubDate>Sat, 07 Dec 2019 21:22:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;여러분들의 데이터는 안전합니까? &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>여러분들의 데이터는 안전합니까? </p><a id="more"></a><p>오늘은 암호화 (Encryption) 복호화(Decryption)에 대한 이야기를 나눠보고자 합니다. </p><h2 id="암호와-복호와"><a href="#암호와-복호와" class="headerlink" title="암호와/복호와"></a>암호와/복호와</h2><p>암호화는 데이터를 암호화 하여서 누군가가 읽을 수 없도록 정보를 전달화는 과정입니다. 암호와에는 여러가지 알고리즘이 쓰임니다. </p><p>복호와는 암호화된 정보를 다시 읽을 수 있게하는 과정으로써 데이터가 누출되더라도 복호화를 하지못하면 암호화된 데이터를 읽을 수 없습니다. </p><h2 id="암호와-종류"><a href="#암호와-종류" class="headerlink" title="암호와 종류"></a>암호와 종류</h2><ol><li><p>단방향 암호: 암호화 후 복호화 할 수 없습니다. 예를 들면 <code>사용자 비밀번호</code> 사용자가 입력한 비밀번호를 암호화 하고 모든 접근자는 암호화 된 코드를 다시 평문으로 볼 수 없습니다. 해킹이 되어도 복호화가 굉장히 어렵습니다. 예외적인 경우로는 <code>RainbowTable</code> 이 있습니다. </p><p>더 자세한 정보: <a href="https://www.youtube.com/watch?v=TeIVhioUAXs" target="_blank" rel="external nofollow noopener noreferrer">참고영상</a></p></li><li><p>양방향 암호: 암호와와 복호화 모두 가능합니다. <code>사용자 주소, 이메일, 전자서명</code> 등과 같이 정보를 재사용해야 되는 경우에 사용합니다. </p><p>양방향 암호에는 크게 두 가지 종류가 있습니다. </p><ul><li><p>대칭형 암호 (비밀키 암호)</p><p>대칭형 암호는 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 동일한 암호화 기법입니다. 예를 들면 “APPLE”를 “ABCDE”로 암호화 했다면 복호화도 반드시 “ABCDE”로 해야됩니다. 예를 들면 <code>AES Algorithm</code></p><p>하지만 대칭형 암호에는 키 배송에 관한 문제가 발생됩니다. 송신 측에서는 데이터를 암호화한 후에 수신 측에 암호키를 전달해야되고 전달하는 과정에서 이 함호 키가 털리면 데이터가 유출됩니다. 그리고 키 관리가 어렵습니다.</p></li></ul></li></ol><ul><li><p>비대칭형 암호 (공개키 암호)</p><p>비대칭현 암호는 암호와 키와 복호화 키가 다릅니다. </p><p>클라이언트와 서버가 각각의 공개키와 비밀키를 갖고, 서로 공개키를 공개합니다. 클라이언트는 서버의 공개키로 데이터를 암호화한 후에 서버로 보내면 서버는 자신의 비밀키를 가지고 클라이언트가 보낸 데이터를 복호화 합니다. 예를 들면 <code>RSA, Diffe-Hellman, ECC, etc</code></p><p><code>공개키</code> 는 공유되지만 <code>암호키</code> 는 공개되지 않기에 공개키가 중간에 탈취되어도 데이터를 안전하게 지킬 수 있습니다. </p><p>하지만 문제는 비대칭형 암호는 대칭형 암호에 비해 느리고 많은 자료를 암호와 복호화 하는데 불편합니다 단점이 있습니다. </p></li></ul><h2 id="암호-알고리즘"><a href="#암호-알고리즘" class="headerlink" title="암호 알고리즘"></a>암호 알고리즘</h2><h3 id="단방향"><a href="#단방향" class="headerlink" title="단방향"></a>단방향</h3><ol><li><code>SHA</code> : 가장 대표적인 해시함수</li><li><code>PBKDF2</code> : 해시함수의 컨테이너인 PBKDF2는 솔트를 적용한 후 해시 함수의 반복 횟수를 임의로 선택할 수 있다. PBKDF2는 구현하기 쉬운 알고리즘이며 SHA와 같이 검증된 해시 함수만 사용합니다.</li><li><code>bcrypt</code> : 패스워드 저장을 목적으로 설계되었으며 가장 많이 쓰이는 알고리즘입니다. 입력값을 72 byte로 해야하기 때문에 조금 사용에 불편함이 있을 수 있습니다. </li><li><code>scrypt</code> : scrypt는 상대적으로 최신 알고리즘이며 위에 알고리즘들 보다 더 성능적으로 뛰어난다고 평가되지만 잘 알려져 있지 않습니다. scrypt는 다이제스트를 생성할 때 메모리 오버헤드를 갖도록 설계되어, 억지 기법 공격 (brute-force attack)을 시도할 때 병렬화 처리가 매우 어렵습니다. 따라서 PBKDF2보다 안전하고 bcrypt에 비해 더 경쟁력 있다고 여겨집니다. </li></ol><h3 id="양방향"><a href="#양방향" class="headerlink" title="양방향"></a>양방향</h3><ol><li><code>AES</code>:  현재 가장 보편적으로 쓰이는 암호와 방식이며 미국 표준 방식인 AES. 128 ~ 256 byte 키를 적용 할 수 있어서 보안성이 뛰어난 공개된 알고리즘입니다. </li><li><code>RSA</code> : 공개키 암호 시스템의 하나로 암호와 뿐만 아니라 전자서명까지 가증한 알고리즘입니다. </li></ol><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://sieunlim.tistory.com/16" target="_blank" rel="external nofollow noopener noreferrer">https://sieunlim.tistory.com/16</a></p><p><a href="https://record22.tistory.com/44" target="_blank" rel="external nofollow noopener noreferrer">https://record22.tistory.com/44</a></p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/12/07/%EC%95%94%ED%98%B8%ED%99%94%EB%B3%B5%ED%98%B8%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Realtime Virus Scanning</title>
      <link>https://mchoi07.github.io/2019/11/20/nifi-virus-scanning/</link>
      <guid>https://mchoi07.github.io/2019/11/20/nifi-virus-scanning/</guid>
      <pubDate>Wed, 20 Nov 2019 20:14:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;To protect our system and computer we should make sure that data which we download is clean. Everytime we bring data to our system or user upload data such as file attachments, we must make sure that data is free from viruses and trojans. &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>To protect our system and computer we should make sure that data which we download is clean. Everytime we bring data to our system or user upload data such as file attachments, we must make sure that data is free from viruses and trojans. </p><a id="more"></a><p>If our system has sensitive data and critical for operation you have to be more cautious about bringing data to your system - cyber attack, nowadays, is being serious and cunning. </p><p>In a normal usecase, we set up Anti Virus (AV) scanner on a file system. AV scanner monitor our file system and RAM in real-time or batch. However, it cannot make sure that each file doesn’t have any malicious content in real-time. In this project, we will use two open source products to detect virus/trojan in realtime. We are going to use <code>Apache Nifi</code> and <code>ClamAV</code> </p><p><a href="https://nifi.apache.org/" target="_blank" rel="external nofollow noopener noreferrer">Apache Nifi</a> is a very powerful, easy to use and stable system to process and distribute data between disparate system. Apache Nifi is a real time data ingestion platform, which can transfer and manage data transfer between different sources and destination systems. </p><p><a href="https://www.clamav.net/" target="_blank" rel="external nofollow noopener noreferrer">ClamAV</a> is an open source antivirus engine for detecting trojans, viruses, malware &amp; other malicious threats. </p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://isutah.com/virus-protection-cleanup/" target="_blank" rel="external nofollow noopener noreferrer">Thumnail Image</a>s</p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/11/20/nifi-virus-scanning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Simulation 02 - Random variable</title>
      <link>https://mchoi07.github.io/2019/07/19/random-variable/</link>
      <guid>https://mchoi07.github.io/2019/07/19/random-variable/</guid>
      <pubDate>Fri, 19 Jul 2019 04:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;Random variable can be generated from a good random number generator. If real variables has moved the reality, we could design a future with a good random variables.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Random variable can be generated from a good random number generator. If real variables has moved the reality, we could design a future with a good random variables.</p><a id="more"></a><blockquote><p>Author: Minkyu Choi<br>Last updated: 07/19/2019</p></blockquote><p><strong>Inverse Transform Method</strong><br>Inverse transform sampling is a method for generating random numbers from any probability distribution by using its inverse cumulative distribution F−1(x)F−1(x). Recall that the cumulative distribution for a random variable XX is FX(x)=P(X≤x)FX(x)=P(X≤x). In what follows, we assume that our computer can, on demand, generate independent realizations of a random variable UU uniformly distributed on [0,1]</p><p><strong>Cutpoint Method</strong><br>This inverse-transform method has the advantage of having an optimal O(n) setup time. However, the average number of steps required to sample X is not optimal, and if several samples of X are needed, then the cutpoint method offers an average number of two comparison steps needed to sample an observation, yet still has an O(n) initial setup time</p><p>Without loss of generality, we can assume that X = [1, n]. Also, let qi = P(X ≤ i). Then the idea behind the cutpoint method is to choose m ≥ n, and define sets Q1, . . . , Qm for which</p><p><img src="/2019/07/19/random-variable/cutpoint.png" alt="Cutpoint Method"></p><p>for all i = 1, . . . , m. In words, the unit interval [0, 1] is partitioned into m equal sub-intervals of the form $[\frac{(i−1)} m,  \frac{i}m)$, i = 1, . . . , m. And when U falls into the i th sub-interval, then Qi contains all the possible qj values for which F −1 (U) = j. That way, instead of searching through all of the q values, we save time by only examining the qj values in Qi , since these are the only possible values for which $F^{-1} (U) = j$.</p><p><strong>Convolution Method</strong></p><ul><li>Sum of n variables: $x = y_1 + y_2 + … y_n$</li><li>Generate n random variate yi’s and sum </li><li>For sums of two variables, pdf of x = convolution of pdfs of y1 and y2. Hence the name </li><li>Although no convolution in generation </li><li>If pdf or CDF = Sum ⇒ Composition </li><li>Variable x = Sum ⇒ Convolution</li></ul><p><strong>Acceptance-Rejection Method</strong><br>Finding an explicit formula for F −1 (y) for the cdf of a rv X we wish to generate, F(x) = P(X ≤ x), is not always possible. Moreover, even if it is, there may be alternative methods for generating a rv distributed as F that is more efficient than the inverse transform method or other methods we have come across. Here we present a very clever method known as the acceptance-rejection method.</p><p><strong>Composition Method</strong><br>Can be used when m can be expressed as a convex combination of other distributions Fi , where we hope to be able to sample from $F_i$ more easily than from F directly.</p><p><img src="/2019/07/19/random-variable/Cm.png" alt="Composition Method"></p><p><strong>References</strong><br><a href="https://newonlinecourses.science.psu.edu/stat414/node/104/" target="_blank" rel="external nofollow noopener noreferrer">Link-1</a><br><a href="https://stephens999.github.io/fiveMinuteStats/inverse_transform_sampling.html" target="_blank" rel="external nofollow noopener noreferrer">Link-2</a><br><a href="http://web.csulb.edu/~tebert/teaching/lectures/552/variate/variate.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-3</a><br><a href="https://www.cse.wustl.edu/~jain/cse567-08/ftp/k_28rvg.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-4</a><br><a href="http://www.columbia.edu/~ks20/4703-Sigman/4703-07-Notes-ARM.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-5</a></p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/07/19/random-variable/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Simulation 01 - Random Number</title>
      <link>https://mchoi07.github.io/2019/07/18/random-number/</link>
      <guid>https://mchoi07.github.io/2019/07/18/random-number/</guid>
      <pubDate>Thu, 18 Jul 2019 13:27:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;A simulation is not real but it can represent the real. It’s because a simulation is an imitation of real situation - it can’t be exact but it can be approximate.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>A simulation is not real but it can represent the real. It’s because a simulation is an imitation of real situation - it can’t be exact but it can be approximate.</p><a id="more"></a><p>Most of simulation models are strated from generating random number because randomness creates value on a simulation modeling. It is really important to give an algorithm that produces a sequence of pseudo-random number (PRNs) $R_1, R_2,…$ that “appear” to be iid Unif(0,1). There are many different Uniform(0,1) Generators.</p><p><strong>Output of random device</strong></p><ul><li>Nice randomness properties. However, Unif(0,1) sequence storage difficult, sot it’s tough to repeat experiment</li><li>Examples:<ul><li>flip a coin</li><li>particle count by Geiger coutner</li><li>least significant digits of atomic clock</li></ul></li></ul><p><strong>Table of random numbers</strong></p><ul><li>List of digits supplied in tables - A Million random Digits with 100,00 Normal Deviates.</li><li>Cumbersome, slow, table too small - not very useful </li></ul><p><strong>Mid-Square</strong></p><ul><li>Idea - Take the middle part of square of the previous random number. John von Neumann was a brilliant and fun-loving guy, but method is terrible</li><li>Example: Take $R_i = X_i/10000$, ∀i, where the Xi’s are positive<br>integers &lt; 10000.</li><li>Set seed $X_0 = 6642$; then $6632^2$ = 43<strong>9834</strong>24</li><li>so $X_1 = 9834$; then $9834^2$ - 96<strong>7075</strong>56</li><li>so $X_2$ = 7075, etc,…</li><li>Unfortunately, positive serial correlation in $R_i$’s. Also, occasionally degenerates; eg., consider $X_i$ = 0003</li></ul><p><strong>Fibonacci</strong></p><ul><li>These methods are also no good!! </li><li>Take $X_i = (X_{i-1} + X_{i-2})mod(m), i = 1,2,…,$ where $R_i = X_i/m$ ,$m$ is the modulus, $X_01,X_0$ are seeds, and $a = b mod m$ if $a$ is the remainer of $b/m$ </li><li>Problem: small numbers follow small numbers</li><li>Also, it’s not possible to get $X_{i-1} &lt; X_{i+1} &lt; X_i$ or </li><li>$X_i &lt; X_{i+1} &lt; X_{i-1} $ (which should occur w.p 1/3)</li><li>$X_{i+1}$ </li></ul><p><strong>Linear congruential (most commonly used in practice</strong></p><ul><li>LCGs are the most widely used generators. These are pretty good when implemented properly. </li><li>$X_i = (aX_{i-1} + c) mod(m)$, where $X_0$ is the seed.</li><li>$R_i = X_i/m, i = 1,2,…$ </li><li>Choose a,c,m carefully to get good stastistical quality and long period or cycle length, i.e., time until LCG starts to repeat itself. </li><li>If $c = 0$, LCG is called a multiplicative generator </li></ul><p><strong>Tausworthe (linear recursion mod 2)</strong></p><ul><li><p>Tausworthe Generator is a kind of multicative recursive generator.</p></li><li><p>$X_{i+1} = (aX_{i-1} + c) mod(2)$, where $X_0$ is the seed.</p></li></ul><p><strong>Reference</strong></p><p>Georgia Tech’s <code>ISYE6644</code> class content</p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/07/18/random-number/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
