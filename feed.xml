<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>https://mchoi07.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 26 Nov 2019 03:37:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>first-post</title>
      <link>https://mchoi07.github.io/2019/11/06/first-post/</link>
      <guid>https://mchoi07.github.io/2019/11/06/first-post/</guid>
      <pubDate>Thu, 07 Nov 2019 02:36:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;Test&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Test</p><a id="more"></a><p>[하나님의 자녀]</p><p>왜 우리가 무언가를 하기위해 어떠한 일을 위해 이땅에 보내졌다고만 생각하게 되었는지..</p><p>아무것도 하지 않아도 아무것도 이루지 못해도 나는 하나님의 자녀. 실수하고 넘어져도 하나님의 자녀. </p><p>하나님의 자녀로서 정체성을 찾으라고 이야기한다. 무엇을 위하여 보내졌는지를 생각하라고 한다. 그런데 우리들중 과연 누가 어떤 구체적인 목적을 위해 부모님으로 부터 태어났을까? 과연 어떤 부모님이 어떤 일을 이루기 위해 우리를 낳고 기르셨을까? </p><p>그렇다기 보다는 두가지의 경우가 있다고 생각한다. 자녀로써 아버지의 일에 시선이 가는경우 또 다른경우는 이버지의 일과 상관없이 나의 길을 가는 경우. 그 어떤 선택도 정답은 아니다. 우리의 선택일뿐. </p><p>창조의 목적? 나는 잘 모르겠다. 내가 하나님의 자녀됨을 진정 안다면. 나는 그 안에서 자유함을 누리는 삶을 워한다. </p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/11/06/first-post/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Simulation 02 - Random variable</title>
      <link>https://mchoi07.github.io/2019/07/19/random-variable/</link>
      <guid>https://mchoi07.github.io/2019/07/19/random-variable/</guid>
      <pubDate>Fri, 19 Jul 2019 04:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;Random variable can be generated from a good random number generator. If real variables has moved the reality, we could design a future with a good random variables.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Random variable can be generated from a good random number generator. If real variables has moved the reality, we could design a future with a good random variables.</p><a id="more"></a><h2 id="Simulation-02-Random-variable"><a href="#Simulation-02-Random-variable" class="headerlink" title="Simulation 02 - Random variable"></a>Simulation 02 - Random variable</h2><blockquote><p>Author: Minkyu Choi<br>Last updated: 07/19/2019</p></blockquote><h3 id="Inverse-Transform-Method"><a href="#Inverse-Transform-Method" class="headerlink" title="Inverse Transform Method"></a>Inverse Transform Method</h3><p>Inverse transform sampling is a method for generating random numbers from any probability distribution by using its inverse cumulative distribution F−1(x)F−1(x). Recall that the cumulative distribution for a random variable XX is FX(x)=P(X≤x)FX(x)=P(X≤x). In what follows, we assume that our computer can, on demand, generate independent realizations of a random variable UU uniformly distributed on [0,1]</p><h3 id="Cutpoint-Method"><a href="#Cutpoint-Method" class="headerlink" title="Cutpoint Method"></a>Cutpoint Method</h3><p>This inverse-transform method has the advantage of having an optimal O(n) setup time. However, the average number of steps required to sample X is not optimal, and if several samples of X are needed, then the cutpoint method offers an average number of two comparison steps needed to sample an observation, yet still has an O(n) initial setup time</p><p>Without loss of generality, we can assume that X = [1, n]. Also, let qi = P(X ≤ i). Then the idea behind the cutpoint method is to choose m ≥ n, and define sets Q1, . . . , Qm for which ![cutpoint](/Users/MinkyuChoi/Google Drive/project/minkyu_choi_blog/source/_posts/20190719-random-variable/cutpoint.png)</p><p>for all i = 1, . . . , m. In words, the unit interval [0, 1] is partitioned into m equal sub-intervals of the form $[\frac{(i−1)} m,  \frac{i}m)$, i = 1, . . . , m. And when U falls into the i th sub-interval, then Qi contains all the possible qj values for which F −1 (U) = j. That way, instead of searching through all of the q values, we save time by only examining the qj values in Qi , since these are the only possible values for which $F^{-1} (U) = j$.</p><h3 id="Convolution-Method"><a href="#Convolution-Method" class="headerlink" title="Convolution Method"></a>Convolution Method</h3><ul><li>Sum of n variables: $x = y_1 + y_2 + … y_n$</li><li>Generate n random variate yi’s and sum </li><li>For sums of two variables, pdf of x = convolution of pdfs of y1 and y2. Hence the name </li><li>Although no convolution in generation </li><li>If pdf or CDF = Sum ⇒ Composition </li><li>Variable x = Sum ⇒ Convolution</li></ul><p>###Acceptance-Rejection Method</p><p>Finding an explicit formula for F −1 (y) for the cdf of a rv X we wish to generate, F(x) = P(X ≤ x), is not always possible. Moreover, even if it is, there may be alternative methods for generating a rv distributed as F that is more efficient than the inverse transform method or other methods we have come across. Here we present a very clever method known as the acceptance-rejection method.</p><p>###Composition Method</p><p>Can be used when m can be expressed as a convex combination of other distributions Fi , where we hope to be able to sample from $F_i$ more easily than from F directly.</p><p>![Composition Method](/Users/MinkyuChoi/Googledrive/project/minkyu_choi_blog/source/_posts/20190719-random-variable/Composition Method.png)</p><p><strong>References</strong><br><a href="https://newonlinecourses.science.psu.edu/stat414/node/104/" target="_blank" rel="external nofollow noopener noreferrer">Link-1</a><br><a href="https://stephens999.github.io/fiveMinuteStats/inverse_transform_sampling.html" target="_blank" rel="external nofollow noopener noreferrer">Link-2</a><br><a href="http://web.csulb.edu/~tebert/teaching/lectures/552/variate/variate.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-3</a><br><a href="https://www.cse.wustl.edu/~jain/cse567-08/ftp/k_28rvg.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-4</a><br><a href="http://www.columbia.edu/~ks20/4703-Sigman/4703-07-Notes-ARM.pdf" target="_blank" rel="external nofollow noopener noreferrer">Link-5</a></p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/07/19/random-variable/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Simulation 01 - Random Number</title>
      <link>https://mchoi07.github.io/2019/07/18/random-number/</link>
      <guid>https://mchoi07.github.io/2019/07/18/random-number/</guid>
      <pubDate>Thu, 18 Jul 2019 13:27:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;A simulation is not real but it can represent the real. It’s because a simulation is an imitation of real situation - it can’t be exact but it can be approximate.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>A simulation is not real but it can represent the real. It’s because a simulation is an imitation of real situation - it can’t be exact but it can be approximate.</p><a id="more"></a><h2 id="Simulation-01-Random-Number"><a href="#Simulation-01-Random-Number" class="headerlink" title="Simulation 01 - Random Number"></a>Simulation 01 - Random Number</h2><blockquote><p>Author: Minkyu Choi<br>Last updated: 07/19/2019</p></blockquote><p>Most of simulation models are strated from generating random number because randomness creates value on a simulation modeling. It is really important to give an algorithm that produces a sequence of pseudo-random number (PRNs) $R_1, R_2,…$ that “appear” to be iid Unif(0,1). There are many different Uniform(0,1) Generators.</p><h3 id="Output-of-random-device"><a href="#Output-of-random-device" class="headerlink" title="Output of random device"></a>Output of random device</h3><ul><li>Nice randomness properties. However, Unif(0,1) sequence storage difficult, sot it’s tough to repeat experiment</li><li>Examples:<ul><li>flip a coin</li><li>particle count by Geiger coutner</li><li>least significant digits of atomic clock</li></ul></li></ul><h3 id="Table-of-random-numbers"><a href="#Table-of-random-numbers" class="headerlink" title="Table of random numbers"></a>Table of random numbers</h3><ul><li>List of digits supplied in tables - A Million random Digits with 100,00 Normal Deviates.</li><li>Cumbersome, slow, table too small - not very useful </li></ul><h3 id="Mid-Square"><a href="#Mid-Square" class="headerlink" title="Mid-Square"></a>Mid-Square</h3><ul><li>Idea - Take the middle part of square of the previous random number. John von Neumann was a brilliant and fun-loving guy, but method is terrible</li><li>Example: Take $R_i = X_i/10000$, ∀i, where the Xi’s are positive<br>integers &lt; 10000.</li><li>Set seed $X_0 = 6642$; then $6632^2$ = 43<strong>9834</strong>24</li><li>so $X_1 = 9834$; then $9834^2$ - 96<strong>7075</strong>56</li><li>so $X_2$ = 7075, etc,…</li><li>Unfortunately, positive serial correlation in $R_i$’s. Also, occasionally degenerates; eg., consider $X_i$ = 0003</li></ul><h3 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h3><ul><li>These methods are also no good!! </li><li>Take $X_i = (X_{i-1} + X_{i-2})mod(m), i = 1,2,…,$ where $R_i = X_i/m$ ,$m$ is the modulus, $X_01,X_0$ are seeds, and $a = b mod m$ if $a$ is the remainer of $b/m$ </li><li>Problem: small numbers follow small numbers</li><li>Also, it’s not possible to get $X_{i-1} &lt; X_{i+1} &lt; X_i$ or </li><li>$X_i &lt; X_{i+1} &lt; X_{i-1} $ (which should occur w.p 1/3)</li><li>$X_{i+1}$ </li></ul><h3 id="Linear-congruential-most-commonly-used-in-practice"><a href="#Linear-congruential-most-commonly-used-in-practice" class="headerlink" title="Linear congruential (most commonly used in practice"></a>Linear congruential (most commonly used in practice</h3><ul><li>LCGs are the most widely used generators. These are pretty good when implemented properly. </li><li>$X_i = (aX_{i-1} + c) mod(m)$, where $X_0$ is the seed.</li><li>$R_i = X_i/m, i = 1,2,…$ </li><li>Choose a,c,m carefully to get good stastistical quality and long period or cycle length, i.e., time until LCG starts to repeat itself. </li><li>If $c = 0$, LCG is called a multiplicative generator </li></ul><h3 id="Tausworthe-linear-recursion-mod-2"><a href="#Tausworthe-linear-recursion-mod-2" class="headerlink" title="Tausworthe (linear recursion mod 2)"></a>Tausworthe (linear recursion mod 2)</h3><ul><li><p>Tausworthe Generator is a kind of multicative recursive generator.</p></li><li><p>$X_{i+1} = (aX_{i-1} + c) mod(2)$, where $X_0$ is the seed.</p></li></ul><p><strong>Reference</strong></p><p>Georgia Tech’s <code>ISYE6644</code> class content</p>]]></content:encoded>
      
      <comments>https://mchoi07.github.io/2019/07/18/random-number/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
